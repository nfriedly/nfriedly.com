{
  "name": "primus",
  "version": "1.1.4",
  "description": "Primus is a simple abstraction around real-time frameworks. It allows you to easily switch between different frameworks without any code changes.",
  "main": "index.js",
  "scripts": {
    "integration": "NODE_ENV=testing ./node_modules/.bin/mocha $(find test -name '*.integration.js')",
    "test": "NODE_ENV=testing ./node_modules/.bin/mocha $(find test -name '*.test.js')",
    "browserify": "browserify example/primus.js -o example/primus.browserify.js --standalone Primus"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/3rd-Eden/primus.git"
  },
  "keywords": [
    "primus",
    "real-time",
    "realtime",
    "websocket",
    "ws",
    "engine.io",
    "socket.io",
    "transformer"
  ],
  "author": {
    "name": "Arnout Kazemier"
  },
  "license": "MIT",
  "dependencies": {
    "extendable": "0.0.x",
    "load": "0.1.x"
  },
  "devDependencies": {
    "browserchannel": "1.0.x",
    "chai": "1.7.x",
    "engine.io": "git://github.com/3rd-Eden/engine.io.git#issue/178",
    "engine.io-client": "0.6.x",
    "jsonh": "0.0.x",
    "mocha": "1.11.x",
    "pre-commit": "0.0.x",
    "socket.io": "0.9.x",
    "socket.io-client": "0.9.x",
    "sockjs": "0.3.x",
    "ws": "0.4.x",
    "sockjs-client-node": "0.0.0",
    "request": "~2.21.0"
  },
  "readme": "# Primus\n\n[![Build Status](https://travis-ci.org/3rd-Eden/primus.png)](https://travis-ci.org/3rd-Eden/primus)\n[![NPM version](https://badge.fury.io/js/primus.png)](http://badge.fury.io/js/primus)\n\nPrimus, the creator god of transformers but now also known as universal wrapper\nfor real-time frameworks. There are a lot of real-time frameworks available for\nNode.js and they all have different opinions on how real-time should be done.\nPrimus provides a common low level interface to communicate in real-time using\nvarious of real-time frameworks.\n\n### Highlights\n\n1. Effortless switching between real-time frameworks and message parsers.\n2. Clean and stream compatible interface for client and server.\n3. Fixes bugs in frameworks and real-time communication where needed.\n4. Build with love and passion for real-time.\n5. Reconnect that actually works.\n\n### Installation\n\nPrimus is released in `npm` and can be installed using:\n\n```\nnpm install primus --save\n```\n\n### Table of Contents\n\n- [Introduction](#primus)\n  - [Highlights](#highlights)\n- [Installation](#installation)\n- [Getting Started](#getting-started)\n- [Connecting from the server](#connecting-from-the-server)\n  - [Broadcasting](#broadcasting)\n  - [Destruction](#destruction)\n- [Connecting from the browser](#connecting-from-the-browser)\n- [Events](#events)\n- [Supported real-time frameworks](#supported-real-time-frameworks)\n  - [Engine.IO](#engineio)\n  - [WebSockets](#websockets)\n  - [BrowserChannel](#browserchannel)\n  - [SockJS](#sockjs)\n  - [Socket.IO](#socketio)\n- [Transformer Inconsistencies](#transformer-inconsistencies)\n- [Plugins](#plugins)\n  - [Extending the Spark/socket](#extending-the-spark--socket)\n  - [Transforming and intercepting messages](#transforming-and-intercepting-messages)\n  - [Community Plugins](#community-plugins)\n- [Scaling](#scaling)\n- [Versioning](#versioning)\n- [License](#license)\n\n### Getting Started\n\nPrimus doesn't ship with real-time frameworks as dependencies, it assumes that\nyou as user adds them your self as a dependency. This is done to keep the module\nas light weight as possible. This works because `require` in will walk through\nyour directories searching for `node_module` folders that have these matching\ndependencies.\n\nPrimus needs to be \"attached\" to a HTTP compatible server. These includes the\nbuild in `http` and `https` servers but also the `spdy` module as it has the\nsame API as node servers. Creating a new Primus instance is relatively straight\nforward:\n\n```js\n'use strict';\n\nvar Primus = require('primus')\n  , http = require('http');\n\nvar server = http.createServer(/* request handler */)\n  , primus = new Primus(server, {/* options */});\n```\n\nIn addition to support different frameworks we've also made it possible to use\ncustom encoding and decoding libraries. We're using `JSON` by default but you\ncould also use `msgpack` or `JSONH` for example (but these parsers need to be\nsupported by Primus, so check out the parser folder for examples). To set parser\nyou can supply a `parser` configuration option:\n\n```js\nvar primus = new Primus(server, { parser: 'JSON' });\n```\n\nAll parsers have an `async` interface for error handling.\n\nAs most libraries come with their own client-side framework for making the\nconnection we've also created a small wrapper for this. The library can be\nretrieved using:\n\n```js\nprimus.library();\n```\n\nWhich returns the client-side library. It's not minified as that is out of the\nscope of this project. You can store this on a CDN or on your static server. Do\nwhat ever you want with it, but I would advice you to regenerate that file every\ntime you redeploy so it always contains a client side library that is compatible\nwith your back-end. To save the file you can use:\n\n```js\nprimus.save(__dirname +'/primus.js');\n```\n\nThis will store the compiled library in your current directory. If you want to\nsave it asynchronously, you can supply the method with an callback method:\n\n```js\nprimus.save(__dirname +'/primus.js', function save(err) {\n\n});\n```\n\nBut to make it easier for you during development we've automatically added an\nextra route to the supplied HTTP server, this will serve the library for you so\nyou don't have to save it. Please note, that this route isn't optimized for\nserving static assets and should only be used during development. In your HTML\npage add:\n\n```html\n<script src=\"/primus/primus.js\"></script>\n```\n\nIf you've configured a different `pathname` in the options deploy on a different\ndomain then your Primus server you would of course need to update the `src`\nattribute to the correct location. It's always available at:\n\n```\n<protocol>://<server location>/<pathname>/primus.js\n```\n\nThe client is cross domain compatible so you don't have to serve it from the\nsame domain you're running Primus on. But please note, that the real-time\nframework you're using might be tied to same domain restrictions.\n\nOnce you're all set up you can start listening for connections. These\nconnections are announced through the `connection` event.\n\n```js\nprimus.on('connection', function (spark) {\n  // spark is the new connection.\n});\n```\n\nDisconnects are announced using a `disconnection` event:\n\n```js\nprimus.on('disconnection', function (spark) {\n  // the spark that disconnected\n});\n```\n\nThe `spark` the actual real-time socket/connection. Sparks have a really low\nlevel interface and only expose a couple properties that are cross engine\nsupported. The interface is modeled towards a Node.js stream compatible\ninterface.\n\n#### spark.headers\n\nThe `spark.headers` property contains contains the headers of either the request\nthat started a handshake with the server or the headers of the actual real-time\nconnection. This depends on the module you are using.\n\n#### spark.address\n\nThe `spark.address` property contains the `ip` and `port` of the\nconnection. If you're running your server behind a reverse proxy it will\nautomatically use the `x-forwarded-for` headers. This way you will always have\nthe address of the connecting client and not the IP address of your proxy.\n\n*Please note that the `port` is probably out of date by the time you're going\nto read it as it's retrieved from an old request, not the request that is\nactive at the time you access this property.*\n\n#### spark.query\n\nThe `spark.query` contains the query string you used to connect to server. It's\nparsed to a object. Please note that this is not available for all supported\ntransformers, but it's proven to be to useful to not implement it because one\nsilly transformer refuses to support it. Yes.. I'm looking at you,\nBrowserChannel and SockJS.\n\n#### spark.id\n\nThis is the connection id we use to identify the connection. This should not be\nseen as a \"session id\" and can change between disconnects and reconnects.\n\n#### spark.write(data)\n\nYou can use the `spark.write` method to send data over the socket. The data is\nautomatically encoded for you using the `parser` that you've set while creating\nthe Primus instance. This method always returns `true` so back pressure isn't\nhandled.\n\n```js\nspark.write({ foo: 'bar' });\n```\n\n#### spark.end()\n\nThe `spark.end()` closes the connection.\n\n#### spark.emits(event, parser)\n\nThis method is mostly used internally. It returns a function that emits assigned\n`event` every time it's called. It only emits the first received argument or the\nresult of the optional `parser` call. The `parser` function receives all\narguments and can parse it down to a single value or just extracts the useful\ninformation from the data. Please note that the data that is received here isn't\ndecoded yet.\n\n```js\nspark.emits('event', function parser(structure) {\n  return structure.data;\n});\n```\n\n#### spark.on('data')\n\nThe `data` event is emitted when a message is received from the client. It's\nautomatically decoded by the specified decoder.\n\n```js\nspark.on('data', function message(data) {\n  // the message we've received.\n});\n```\n\n#### spark.on('end')\n\nThe `end` event is emitted when the client has disconnected.\n\n```js\nprimus.on('connection', function (spark) {\n  console.log('connection has the following headers', spark.headers);\n  console.log('connection was made from', spark.address);\n  console.log('connection id', spark.id);\n\n  spark.on('data', function (data) {\n    console.log('received data from the client', data);\n\n    //\n    // Always close the connection if we didn't receive our secret imaginary handshake.\n    //\n    if ('foo' !== data.secrethandshake) spark.end();\n    spark.write({ foo: 'bar' });\n    spark.write('banana');\n  });\n\n  spark.write('Hello world');\n})\n```\n\n### Broadcasting\n\nBroadcasting allows you to write a message to every connected `Spark` on your server. \nThere are 2 different ways of doing broadcasting in Primus. The easiest way is to \nuse the `Primus#write` method which will write a message to every connected user:\n\n```js\nprimus.write(message);\n```\n\nThere are cases where you only want to broadcast a message to a smaller group of \nusers. To make it easier to do this, we've added a `Primus#forEach` method which \nallows you to iterate over all active connections.\n\n```js\nprimus.forEach(function (spark, id, connections) {\n  if (spark.query.foo !== 'bar') return;\n\n  spark.write('message');\n});\n```\n\n### Destruction\n\nIn rare cases you might need to destroy the Primus instance you've created. You\ncan use the `primus.destroy()` or `primus.end()` method for this. This method\naccepts an Object which allows you to configure how you want the connections to\nbe destroyed:\n\n- `close` Close the HTTP server that Primus received. Defaults to `true`.\n- `end` End all active connections. Defaults to `true`.\n- `timeout` Clean up the server and optionally, it's active connections after\n  the specified amount of timeout. Defaults to `0`.\n\nThe timeout is especially useful if you want gracefully shutdown your server but\nreally don't want to wait an infinite amount of time.\n\n```js\nprimus.destroy({ timeout: 10000 });\n```\n\n### Connecting from the Browser.\n\nPrimus comes with it's client framework which can be compiled using\n`primus.library()` as mentioned above. To create a connection you can simply\ncreate a new Primus instance:\n\n```js\nvar primus = new Primus(url, { options });\n\n//\n// But it can be easier, with some syntax sugar.\n//\nvar primus = Primus.connect(url, { options });\n```\n\n#### primus.write(message)\n\nOnce you've created your Primus instance you're ready to go. When you want to\nwrite data to your server you can just call the `.write` method:\n\n```js\nprimus.write('message');\n```\n\nIt automatically encodes your messages using the parser that you've specified on\nthe server. So sending objects back and forth between the server is nothing\ndifferent then just writing:\n\n```js\nprimus.write({ foo: 'bar' });\n```\n\nWhen you are sending messages to the server, you don't have to wait for the\n`open` event to happen, the client will automatically buffer all the data you've\nsend and automatically write it to the server once it's connected. The client\nsupports a couple of different events.\n\n#### primus.on('data')\n\nThe `data` event is the most important event of the whole library. It's emitted\nwhen we receive data from the server. The data that is received is already\ndecoded by the specified parser.\n\n```js\nprimus.on('data', function message(data) {\n  console.log('Received a new message from the server', data);\n});\n```\n\n#### primus.on('open')\n\nThe `open` event is emitted when we've successfully created a connection with\nthe server. It will also be emitted when we've successfully reconnected when the\nconnection goes down unintentionally.\n\n```js\nprimus.on('open', function open() {\n  console.log('Connection is alive and kicking');\n});\n```\n\n#### primus.on('error')\n\nThe `error` event is emitted when something breaks that is out of our control.\nUnlike Node.js, we do not throw an error if no error event listener is\nspecified. The cause of an error could be that we've failed to encode or decode\na message or we failed to create a connection.\n\n```js\nprimus.on('error', function error(err) {\n  console.error('Something horrible has happened', err, err.message);\n});\n```\n\n#### primus.on('reconnect')\n\nThe `reconnect` event is emitted when we're attempting to reconnect to the\nserver. This all happens transparently and it's just a way for you to know when\nthese reconnects are actually happening.\n\n```js\nprimus.on('reconnect', function () {\n  console.log('Reconnect attempt started');\n});\n```\n\n### primus.on('reconnecting')\n\nLooks a lot like the `reconnect` event mentioned above, but it's emitted when\nwe've detected that connection went/is down and we're going to start a reconnect\noperation. This event would be ideal to update your application's UI that you're\nconnection is down and you are trying to reconnect in x seconds.\n\n```js\nprimus.on('reconnecting', function (opts) {\n  console.log('Reconnecting in %d ms', opts.timeout);\n  console.log('This is attempt %d out of %d', opts.attempt, opts.retries);\n});\n```\n\n#### primus.on('end')\n\nThe `end` event is emitted when we've closed the connection. When this event is\nemitted you should consider your connection to be fully dead with no way of\nreconnecting. But it's also emitted when the server closes the connection.\n\n```js\nprimus.on('end', function () {\n  console.log('Connection closed');\n});\n```\n\n#### primus.end()\n\nWhen you want to close the connection you can call the `primus.end()` method.\nAfter this the connection should be considered dead and a new connection needs\nto be made using `Primus.connect(url)` or `primus = new Primus(url)` if you want\nto talk with the server again.\n\n```js\nprimus.end();\n```\n\n#### Reconnecting\n\nWhen the connection goes down unexpectedly a automatic reconnect process is\nstarted. It's using a randomized exponential backoff algorithm to prevent\nclients to DDOS your server when you reboot as they will all be re-connecting at\ndifferent times. The reconnection can be configured using the `options` argument\nin `Primus` and you should add these options to the `backoff` property:\n\n```js\nprimus = Primus.connect(url, {\n  backoff: {\n    maxDelay: Infinity // Number: The max delay for a reconnect retry.\n  , minDelay: 500 // Number: The minimum delay before we reconnect.\n  , retries: 10 // Number: How many times should we attempt to reconnect.\n  , factor: 2 // Number The backoff factor.\n  }\n});\n```\n\nPlease do note when we reconnect, you will receive a new `connection` event on\nthe server. As the previous connection was completely dead and should there for\nbe considered a new connection.\n\nIf you are interested in learning more about the backoff algorithm you might\nwant to read http://dthain.blogspot.nl/2009/02/exponential-backoff-in-distributed.html\n\n```js\nvar primus = Primus.connect(url);\n\nprimus.on('data', function (message) {\n  console.log('received a message', message);\n\n  primus.write({ echo: message });\n});\n\nprimus.write('hello world');\n```\n\n### Connecting from the server\n\nThe client-side library has been made compatible with Node.js so the same code\nbase can be re-used for server side connections. There are two ways of creating\na server side client.\n\n1. When you've created your `primus` instance you can access the `Socket`\n   property on it. This `Socket` is automatically configured to connect to the\n   correct pathname, using the same `transformer` and `parser` that you've\n   specified when you created your `primus` instance.\n\n   ```js\n   var primus = new Primus(server, { transformer: transformer, parser: parser })\n     , Socket = primus.Socket;\n\n   var client = new Socket('http://localhost:8080');\n   //\n   // It has the same interface as the client, so you can just socket.write or\n   // listen for the `open` events etc.\n   //\n   ```\n2. You might need to connect from a different node process where you don't have\n   access to your `primus` instance and the compatible `Socket` instance. For\n   these cases there a special `createSocket` method where you can specify the\n   `transformer`, `parser`, `plugin` that you are using on your server to create\n   another compatible socket. \n\n   ```js\n   var Socket = Primus.createSocket({ transformer: transformer, parser: parser })\n     , client = new Socket('http://localhost:8080');\n  ```\n\n  If you do not know which transformers, parsers are used on the server, we\n  expose a small JSON \"spec\" file that exposes this information. The\n  specification can be reached on the `/<pathname>/spec` and will output the\n  following JSON document:\n\n  ```json\n  {\n    \"version\":\"1.0.1\",\n    \"pathname\":\"/primus\",\n    \"parser\":\"json\",\n    \"transformer\":\"websockets\"\n  }\n  ```\n\n### Events\n\nPrimus is build upon the Stream and EventEmitter interfaces. This is a summary\nof the events emitted by Primus.\n\nEvent                 | Usage       | Location      | Description\n----------------------|-------------|---------------|----------------------------------------\n`outgoing::reconnect` | private     | client        | Transformer should reconnect.\n`reconnecting`        | **public**  | client        | We're scheduling a reconnect.\n`reconnect`           | **public**  | client        | Reconnect attempt is about to be made.\n`outgoing::open`      | private     | client/spark  | Transformer should connect.\n`incoming::open`      | private     | client/spark  | Transformer has connected.\n`open`                | **public**  | client        | Connection is open.\n`incoming::error`     | private     | client        | Transformer received error.\n`error`               | **public**  | client/spark  | An error happened.\n`incoming::data`      | private     | client/server | Transformer received data.\n`outgoing::data`      | private     | client/spark  | Transformer should write data.\n`data`                | **public**  | client/spark  | We received data.\n`incoming::end`       | private     | client/spark  | Transformer closed the connection.\n`outgoing::end`       | private     | client/spark  | Transformer should close connection.\n`end`                 | **public**  | client        | The connection has closed.\n`connection`          | **public**  | server        | We received a new connection.\n`disconnection`       | **public**  | server        | A connection closed.\n`initialised`         | **public**  | server        | The server is initialised.\n\n### Supported Real-time Frameworks\n\nThe following transformers/transports are supported in Primus:\n\n#### Engine.IO\n\nEngine.IO is the low level transport functionality of Socket.IO 1.0. It supports\nmultiple transports for creating a real-time connection. It uses transport\nupgrading instead of downgrading which makes it more resilient to blocking\nproxies and firewalls. To enable `engine.io` you need to install the `engine.io`\nmodule:\n\n```\nnpm install engine.io --save\n```\n\nAnd tell `Primus` that you want to us `engine.io` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'engine.io' });\n```\n\nIf you want to use the client interface inside of Node.js you also need to\ninstall the `engine.io-client`:\n\n```\nnpm install engine.io-client --save\n```\n\nAnd then you can access it from your server instance:\n\n```js\nvar Socket = primus.Socket;\n  , socket = new Socket('url');\n```\n\n#### WebSockets\n\nIf you are targeting a high end audience or maybe just something for internal\nuses you can use a pure WebSocket server. This uses the `ws` WebSocket module\nwhich is known to be one if not the fastest WebSocket server available in\nNode.js and supports all protocol specifications. To use pure WebSockets you\nneed to install the `ws` module:\n\n```\nnpm install ws --save\n```\n\nAnd tell `Primus` that you want to use `WebSockets` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'websockets' });\n```\n\nThe `WebSockets` transformer comes with build in client support and can be\naccessed using:\n\n```js\nvar Socket = primus.Socket;\n  , socket = new Socket('url');\n```\n\n#### Browserchannel\n\nBrowserchannel was the original technology that GMail used for their real-time\ncommunication. It's designed for same domain communication and does not use\nWebSockets. To use browserchannel you need to install the `browserchannel`\nmodule:\n\n```\nnpm install browserchannel --save\n```\n\nAnd tell `Primus` that you want to use `browserchannel` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'browserchannel' });\n```\n\nThe `browserchannel` transformer comes with build in node client support and can be\naccessed using:\n\n```js\nvar Socket = primus.Socket;\n  , socket = new Socket('url');\n```\n\n#### SockJS\n\nSockJS is a real-time server that focuses on cross-domain connections and does\nthis by using multiple transports. To use SockJS you need to install the\n`sockjs` module:\n\n```\nnpm install sockjs --save\n```\n\nAnd tell `Primus` that you want to use `sockjs` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'sockjs' });\n```\n\nIf yo want to use the client interface inside of Node.js you also need to\ninstall the `sockjs-client-node` module:\n\n```\nnpm install sockjs-client-node --save\n```\n\nAnd then you can access it from your server instance:\n\n```js\nvar Socket = primus.Socket;\n  , socket = new Socket('url');\n```\n\n#### Socket.IO\n\nThe Socket.IO transport was written against Socket.IO 0.9.x. It was one of the\nfirst real-time servers written on Node.js and is one of the most used modules\nin Node.js. It uses multiple transports to connect the server. To use Socket.IO\nyou need to install the `socket.io` module:\n\n```\nnpm install socket.io --save\n```\n\nAnd tell `Primus` that you want to use `socket.io` as transformer:\n\n```js\nvar primus = new Primus(server, { transformer: 'socket.io' });\n```\n\nIf you want to use the client interface inside of Node.js you also need to\ninstall the `socket.io-client`:\n\n```\nnpm install socket.io-client --save\n```\n\nAnd then you can access it from your server instance:\n\n```js\nvar Socket = primus.Socket;\n  , socket = new Socket('url');\n```\n\nAs you can see from the examples above, it doesn't matter how you write the name\nof the transformer, we just `toLowerCase()` everything.\n\n### Transformer Inconsistencies\n\n- Browserchannel does not give you access to the `remotePort` of the incoming\n  connection. So when you access `spark.address` the `port` property will be set\n  to `1337` by default.\n- Browserchannel and SockJS do not support connections with query strings. You\n  can still supply a query string in the `new Primus('http://localhost:80?q=s')`\n  but it will not be accessible in the `spark.query` property.\n- Browserchannel is the only transformer that does not support cross domain\n  connections.\n- SockJS and Browserchannel are originally written in CoffeeScript which can\n  make it harder to debug when their internals are failing.\n- Engine.IO and SockJS do not ship their client-side library with their server\n  side component. We're bundling a snapshot of these libraries inside of Primus.\n  We will always be targeting the latest version of these transformers when we\n  bundle the library.\n- There are small bugs in Engine.IO that are causing our tests to fail. I've\n  submitted patches for these bugs, but they have been reject for silly reasons.\n  The bug causes closed connections to say open. If you're experiencing this you\n  can apply this [patch](http://github.com/3rd-Eden/engine.io/commit/0cf81270e9d5700).\n\n### Plugins\n\nPrimus was build as low level interface where you can build your applications\nupon. At it's core, it's nothing more than something that passes messages back\nand forth between the client and server. To make it easier for developers to\nswitch to Primus we've developed a simple but effective plugin system that\nallows you to extend primus's functionality.\n\nPlugins are added on the server side in the form of an `Object`:\n\n```js\nprimus.use('name', {\n  server: function (primus, options) {},\n  client: function (primus, options) {},\n  library: 'client side library'\n});\n```\n\nOr you can pass the plugin `Object` directly in to the constructor:\n\n```js\nvar primus = new Primus(server, { plugin: {\n  name: {\n    server: function (primus, options) {},\n    client: function (primus, options) {},\n    library: 'client side library'\n  }\n}})\n```\n\nThe server function is only executed on the server side and receives 2\narguments:\n\n1. A reference to the initialized primus server.\n2. The options that we're passed in to the `new Primus(server, { options })`\n   constructor. So the plugins can be configured through the same interface.\n\nThe client receives the same arguments:\n\n1. A reference to the initialized primus client.\n2. The options that we're passed in the `new Primus(url, { options })`\n   constructor. So the plugin in configured through the same interface.\n\nThe only thing you need to remember is that the client is stored in the library\nusing `toString()` so it cannot have any references out side the client's\nclosure. But luckily, there's a `library` property that will also be included on\nthe client side when it's specified.\n\n#### Extending the Spark / Socket\n\nThe server has a `.Spark` property that can be extended. This allows you to\neasily add new functionality to the socket. For example adding join room\nfunction would be as easy as:\n\n```js\nprimus.use('rooms', {\n  server: function (primus) {\n    var Spark = primus.Spark;\n\n    Spark.prototype.join = function () {\n      // implement room functionality.\n    };\n  }\n});\n```\n\n#### Transforming and intercepting messages\n\nIntercepting and transforming messages in something that a lot of plugins\nrequire. When your building an `EventEmitter` plugin or something else you\nprobably don't want the default `data` event to be emitted but your custom\nevent. There are 2 different types of messages that can be transformed:\n\n1. `incoming` These messages are being received by the server.\n2. `outgoing` These messages are being send to the client.\n\nThe transformer is available on both the client and the server and share, like\nyou would have expected the same identical API. Adding a new transformer is\nrelatively straight forward:\n\n```js\nprimus.transform('incoming', function (packet) {\n  //\n  // The packet.data contains the actual message that either received or\n  // transformed.\n  //\n  \n  // This would transform all incoming messages to foo;\n  packet.data = 'foo';\n\n  // If you are handling the message and want to prevent the `data` event from\n  // happening, simply `return false` at the end of your function. No new\n  // transformers will be called, and the event won't be emitted.\n});\n```\n\nThese transformations can easily be done in the plugins:\n\n```js\nprimus.use('name', {\n  server: function (primus) {\n    primus.transform('outgoing', function (packet) {\n      packet.data = 'foo';\n    });\n\n    primus.transform('incoming', function (packet) {\n      if (packet.data === 'foo') packet.data = 'bar';\n    });\n  },\n\n  client: function (primus) {\n    primus.transform('outgoing', function (packet) {\n      packet.data = 'foo';\n    });\n\n    primus.transform('incoming', function (packet) {\n      if (packet.data === 'foo') packet.data = 'bar';\n    });\n  }\n});\n```\n\n#### Community Plugins\n\nThese are plugins created by our amazing community. Do you have a module that\nyou want to have listed here? Make sure it has test suite and runs on [Travis CI].\nAfter that open a pull request where you added your module to this README and\nsee it be merged automatically.\n\n<dl>\n  <dt><a href=\"http://github.com/cayasso/primus-rooms\">primus-rooms</a></dt>\n  <dd>\n    A module that adds rooms capabilities to Primus. It's based on the rooms\n    implementation of Socket.IO.\n  </dd>\n  <dd>\n    <a href=\"https://travis-ci.org/cayasso/primus-rooms\">\n      <img src=\"https://travis-ci.org/cayasso/primus-rooms.png?branch=master\" alt=\"Build Status\" />\n    </a>\n    <a href=\"http://badge.fury.io/js/primus-rooms\">\n      <img src=\"https://badge.fury.io/js/primus-rooms.png\" alt=\"NPM version\" />\n    </a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"http://github.com/cayasso/primus-multiplex\">primus-multiplex</a></dt>\n  <dd>\n    A module that adds multiplexing capabilities to Primus.\n  </dd>\n  <dd>\n    <a href=\"https://travis-ci.org/cayasso/primus-multiplex\">\n      <img src=\"https://travis-ci.org/cayasso/primus-multiplex.png?branch=master\" alt=\"Build Status\" />\n    </a>\n    <a href=\"http://badge.fury.io/js/primus-multiplex\">\n      <img src=\"https://badge.fury.io/js/primus-multiplex.png\" alt=\"NPM version\" />\n    </a>\n  </dd>\n</dl>\n\n<dl>\n  <dt><a href=\"http://github.com/cayasso/primus-emitter\">primus-emitter</a></dt>\n  <dd>\n    A module that adds emitter capabilities to Primus.\n  </dd>\n  <dd>\n    <a href=\"https://travis-ci.org/cayasso/primus-emitter\">\n      <img src=\"https://travis-ci.org/cayasso/primus-emitter.png?branch=master\" alt=\"Build Status\" />\n    </a>\n    <a href=\"http://badge.fury.io/js/primus-emitter\">\n      <img src=\"https://badge.fury.io/js/primus-emitter.png\" alt=\"NPM version\" />\n    </a>\n  </dd>\n</dl>\n\n[Travis CI]: https://travis-ci.org/\n\n### Scaling\n\nScaling Primus is as simple as sticking it behind a load balancer that supports\nsticky sessions and run multiple versions of your application. This is a vital\nfeature that your load balancer needs to support. This ensures that the incoming\nrequests always go back to the same server. If your load balancer does not\nsupport sticky sessions, get an other one. I highly recommend\n[HAProxy](http://haproxy.1wt.eu/). According to my own testing it the fastest\nand best proxy available that supports WebSockets. See\nhttps://github.com/observing/balancerbattle for more detailed information.\n\n### Versioning\n\nAll `0.x.x` releases should be considered unstable and not ready for production.\nThe version number is laid out as: `major.minor.patch` and tries to follow\nsemver as closely as possible but this is how we use our version numbering:\n\n<dl>\n  <dt>major</dt>\n  <dd>\n    <p>\n      A major and possible breaking change has been made in the primus core.\n      These changes are not backwards compatible with older versions.\n    </p>\n  </dd>\n  <dt>minor</dt>\n  <dd>\n    <p>\n      New features are added or a big change has happened with one of the\n      real-time libraries that we've supporting.\n    </p>\n  </dd>\n  <dt>patch</dt>\n  <dd>\n    <p>\n      A bug has been fixed, without any major internal and breaking changes.\n    </p>\n  </dd>\n</dl>\n\n### License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/3rd-Eden/primus/issues"
  },
  "_id": "primus@1.1.4",
  "_from": "primus@~1.1.4"
}
